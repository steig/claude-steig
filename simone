#!/usr/bin/env bash
# Simone Framework - Performance-Optimized Edition
# Main command interface with automatic performance optimization

set -euo pipefail

# Check if we're in a Simone project
if [[ ! -d ".simone" ]]; then
    echo "❌ Not in a Simone project directory"
    echo "Run 'simone init' to initialize a new project"
    exit 1
fi

# Source performance modules if available
if [[ -f ".simone/01_UTILS/performance-main.sh" ]]; then
    source ".simone/01_UTILS/performance-main.sh"
    PERF_ENABLED=true
else
    PERF_ENABLED=false
fi

# Source quality validation system
if [[ -f ".simone/01_UTILS/quality-validation.sh" ]]; then
    source ".simone/01_UTILS/quality-validation.sh"
    QUALITY_ENABLED=true
else
    QUALITY_ENABLED=false
fi

# Main command routing with UX improvements
case "${1:-help}" in
    # NEW: Simplified aliases
    "quick")
        # Alias for simple task creation
        shift
        echo "🚀 Creating simple task..."
        echo "This bypasses complex metadata for quick productivity."
        echo
        read -p "Task title: " -r task_title
        read -p "What needs to be done? " -r task_description
        
        # Create simple task without quality gates
        task_id="T$(date +%s | tail -c 4)"
        mkdir -p .simone/04_GENERAL_TASKS
        cat > ".simone/04_GENERAL_TASKS/${task_id}_${task_title// /_}.md" << EOF
# $task_title

## Description
$task_description

## Mode
Simple task - minimal overhead, maximum productivity

## Next Steps
Execute with: \`/project:simone:do_task ${task_id}\`
EOF
        echo "✅ Simple task created: $task_id"
        echo "🔄 Execute with: /project:simone:do_task $task_id"
        exit 0
        ;;
    "auto")
        # Alias for automated task execution
        shift
        echo "🤖 Starting automated task execution..."
        echo "Use Claude Code command: /project:simone:do_task_auto $1"
        exit 0
        ;;
    "task")
        # Default to standard task creation (original behavior)
        shift
        exec "$0" task create "$@"
        ;;
    "quickstart")
        # NEW: 15-minute project setup
        echo "🚀 Simone Quickstart - Get productive in 15 minutes!"
        echo "=================================================="
        echo
        echo "This will create a minimal Simone project optimized for immediate productivity."
        echo "Advanced features (MCP servers, quality enforcement) can be added later."
        echo
        read -p "Project name (or press Enter for current directory): " -r project_name
        project_name=${project_name:-${PWD##*/}}
        
        echo
        echo "📝 Quick project description (just enough to get started):"
        read -p "What are you building? " -r quick_description
        
        # Create minimal structure
        mkdir -p .simone/{02_REQUIREMENTS,03_SPRINTS,04_GENERAL_TASKS,99_TEMPLATES}
        
        # Create simple manifest
        cat > .simone/00_PROJECT_MANIFEST.md << EOF
# $project_name

## Description
$quick_description

## Quick Start Mode
- **Mode**: Simplified setup for immediate productivity
- **Features**: Basic task management, standard templates
- **Upgrade**: Run \`simone enable --features\` to add advanced capabilities

## Next Steps
1. Create your first task: \`simone quick "Your first task"\`
2. Execute it: Use Claude Code with \`/project:simone:do_task\`
3. Add features: \`simone enable --quality\` or \`simone enable --mcp\`
EOF

        echo
        echo "✅ Quickstart complete! Your project is ready."
        echo "📋 Next steps:"
        echo "   1. Create first task: simone quick \"Implement login page\""
        echo "   2. Execute with Claude: /project:simone:do_task T001"
        echo "   3. Add features later: simone enable --help"
        exit 0
        ;;
    "init"|"initialize")
        # Initialize new Simone project with quality enforcement
        echo "🚀 Initializing Simone project..."
        echo
        
        # Quality Gate: Require proper project description
        echo "📝 Project Setup - Quality validation required"
        echo "============================================="
        echo
        
        # Get project description with quality validation
        echo "Enter a detailed project description:"
        echo "(Minimum 10 meaningful words, be specific about goals and scope)"
        echo
        read -p "Description: " -r project_description
        
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            if ! validate_input_quality "$project_description" 10 "Project Description" false; then
                echo
                echo "❌ Project initialization cancelled due to insufficient description quality."
                echo "Please provide a detailed, specific project description and try again."
                exit 1
            fi
        fi
        
        # Create directory structure
        mkdir -p .simone/{00_PROJECT_MANIFEST,01_UTILS,02_REQUIREMENTS,03_SPRINTS,04_GENERAL_TASKS,05_ARCHITECTURAL_DECISIONS,99_TEMPLATES,.cache}
        
        # Copy performance modules if available
        if [[ -d "$(dirname "$0")/.simone/01_UTILS" ]]; then
            cp -r "$(dirname "$0")/.simone/01_UTILS"/* .simone/01_UTILS/ 2>/dev/null || true
        fi
        
        # Create quality project manifest with actual description
        cat > .simone/00_PROJECT_MANIFEST.md << EOF
# Project Manifest

## Project: ${PWD##*/}
## Version: 0.1.0
## Created: $(date +%Y-%m-%d)
## Framework: Simone Optimized

### Description
$project_description

### Quality Standards
- Input validation: enabled
- Quality scoring: enabled
- Lazy pattern detection: enabled
- Progressive restrictions: enabled

### Performance Features
- SQLite task indexing: enabled
- Template caching: enabled
- Command optimization: enabled

### Success Criteria
[To be defined based on project requirements]

### Risk Assessment
[To be completed during project planning]
EOF
        
        # Initialize performance if available
        if [[ "$PERF_ENABLED" == "true" ]]; then
            init_simone_performance
        fi
        
        # Log initial quality metrics
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            local quality_score
            quality_score=$(calculate_quality_score "$project_description" 10 "Project Description")
            local word_count
            word_count=$(count_meaningful_words "$project_description")
            log_quality_metrics "project_init" "$quality_score" "$word_count"
        fi
        
        echo
        echo "✅ Simone project initialized with quality enforcement enabled"
        echo "📊 All future commands will validate input quality to prevent lazy usage"
        ;;
        
    "status")
        if [[ "$PERF_ENABLED" == "true" ]]; then
            simple_status
        else
            echo "📊 Project Status"
            find .simone -name "*.md" -type f | wc -l | xargs echo "Total files:"
        fi
        ;;
        
    "search")
        shift
        if [[ "$PERF_ENABLED" == "true" ]]; then
            simple_search "$@"
        else
            grep -r "$@" .simone --include="*.md"
        fi
        ;;
        
    "task"|"tasks")
        shift
        case "${1:-list}" in
            "create"|"new")
                # NEW: Parse flags for quality bypass
                BYPASS_QUALITY=false
                URGENT_MODE=false
                SIMPLE_MODE=false
                
                while [[ $# -gt 0 ]]; do
                    case $1 in
                        --urgent)
                            URGENT_MODE=true
                            echo "⚡ URGENT MODE: Quality gates relaxed for critical work"
                            shift
                            ;;
                        --bypass)
                            BYPASS_QUALITY=true
                            echo "🚨 BYPASS MODE: All quality validation disabled"
                            read -p "Reason for bypass: " -r bypass_reason
                            shift
                            ;;
                        --simple)
                            SIMPLE_MODE=true
                            echo "🚀 SIMPLE MODE: Minimal metadata for quick productivity"
                            shift
                            ;;
                        --standard)
                            # Default mode, do nothing
                            shift
                            ;;
                        *)
                            break
                            ;;
                    esac
                done
                
                # Quality Gate: Validate project manifest (unless bypassed)
                if [[ "$QUALITY_ENABLED" == "true" && "$BYPASS_QUALITY" == "false" ]]; then
                    if ! validate_project_manifest; then
                        if [[ "$URGENT_MODE" == "true" ]]; then
                            echo "⚠️  WARNING: Project manifest quality low, but proceeding due to urgent flag"
                        else
                            echo
                            echo "❌ Task creation blocked. Please improve project manifest quality first."
                            echo "💡 TIP: Use --urgent for critical work or --bypass for emergencies"
                            exit 1
                        fi
                    fi
                fi
                
                # Interactive task creation with adaptive validation
                if [[ "$SIMPLE_MODE" == "true" ]]; then
                    echo "📝 Simple Task Creation"
                    echo "======================"
                else
                    echo "📝 Task Creation - Quality validation required"
                    echo "============================================="
                fi
                echo
                
                # Get task details with validation
                read -p "Task title: " -r task_title
                echo
                if [[ "$SIMPLE_MODE" == "true" ]]; then
                    echo "Brief description:"
                    read -r task_description
                    acceptance_criteria="Task completed successfully"
                else
                    echo "Task description (explain what needs to be done and why):"
                    read -r task_description
                    echo
                    echo "Acceptance criteria (how will you know it's complete?):"
                    read -r acceptance_criteria
                fi
                echo
                
                # Validate task inputs (with escape hatches)
                if [[ "$QUALITY_ENABLED" == "true" && "$BYPASS_QUALITY" == "false" && "$SIMPLE_MODE" == "false" ]]; then
                    if ! validate_task_creation "$task_title" "$task_description" "$acceptance_criteria"; then
                        if [[ "$URGENT_MODE" == "true" ]]; then
                            echo "⚠️  WARNING: Quality below standards, but proceeding due to urgent flag"
                            echo "📝 NOTE: Please improve quality when time permits"
                        else
                            echo
                            echo "❌ Task creation cancelled due to insufficient quality."
                            echo "💡 TIP: Use --urgent for time-critical work or --simple for quick tasks"
                            echo "📖 HELP: Use --bypass with justification for emergencies"
                            exit 1
                        fi
                    fi
                fi
                
                # Log quality bypass if used
                if [[ "$BYPASS_QUALITY" == "true" || "$URGENT_MODE" == "true" ]]; then
                    echo "$(date '+%Y-%m-%d %H:%M:%S')|task_creation|bypass|$bypass_reason" >> .simone/.cache/quality-bypasses.log
                fi
                
                if [[ "$PERF_ENABLED" == "true" ]]; then
                    fast_create_task "general" "$task_title" "${3:-medium}" "${4:-unassigned}"
                else
                    echo "✅ Creating task: $task_title"
                    echo "   Description: $task_description"
                    echo "   Acceptance: $acceptance_criteria"
                    # Basic task creation would go here
                fi
                ;;
            "list")
                if [[ "$PERF_ENABLED" == "true" ]]; then
                    query_tasks "SELECT id, title, status, priority FROM tasks ORDER BY updated DESC LIMIT 20;"
                else
                    find .simone -name "*.md" -type f | head -20
                fi
                ;;
        esac
        ;;
        
    "sprint")
        shift
        # Quality Gate: Validate project manifest before sprint operations
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            if ! validate_project_manifest; then
                echo
                echo "❌ Sprint operations blocked. Please improve project manifest quality first."
                exit 1
            fi
        fi
        
        if [[ "$PERF_ENABLED" == "true" ]]; then
            simple_sprint_status "$@"
        else
            echo "Sprint management requires performance modules"
        fi
        ;;
        
    "blitz")
        shift
        echo "🚀 Sprint Blitz Automation"
        echo "========================="
        echo
        echo "⚠️  WARNING: This command executes ALL tasks in a sprint with minimal human intervention."
        echo
        
        # Quality Gate: Enhanced validation for dangerous blitz mode
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            echo "🔒 SAFETY CHECK: Blitz mode requires high-quality project foundation"
            echo "------------------------------------------------------------"
            echo
            
            # Validate project manifest
            if ! validate_project_manifest; then
                echo
                echo "❌ Blitz mode blocked. Project manifest quality insufficient."
                exit 1
            fi
            
            # Check recent quality history
            if ! check_project_quality_history; then
                echo
                echo "❌ Blitz mode blocked due to recent low-quality inputs."
                echo "Please improve project planning quality before using automated execution."
                exit 1
            fi
            
            # Generate quality report
            echo "📊 Current project quality status:"
            generate_quality_report
            echo
            
            # Final confirmation
            echo "🚨 FINAL WARNING: Blitz mode will execute tasks automatically."
            echo "Are you confident in the quality of your project planning?"
            echo
            read -p "Type 'EXECUTE' to confirm blitz mode: " -r confirm
            
            if [[ "$confirm" != "EXECUTE" ]]; then
                echo "❌ Blitz mode cancelled. Good decision - take time to plan properly."
                exit 0
            fi
            
            echo
            echo "✅ Quality validation passed. Proceeding with blitz mode."
            echo
        fi
        
        echo "Use Claude Code with: /project:simone:blitz [sprint_id]"
        echo
        echo "For the full command template, see: .simone/99_TEMPLATES/blitz.md"
        ;;
        
    "perf"|"performance")
        shift
        if [[ "$PERF_ENABLED" == "true" ]]; then
            perf_command "$@"
        else
            echo "❌ Performance modules not installed"
            echo "Copy .simone/01_UTILS from the Simone repository"
        fi
        ;;
        
    "enable")
        # NEW: Progressive feature enablement
        shift
        case "${1:-help}" in
            "--quality"|"quality")
                echo "🔒 Enabling Quality Enforcement System..."
                if [[ ! -f ".simone/01_UTILS/quality-validation.sh" ]]; then
                    echo "📥 Installing quality validation system..."
                    mkdir -p .simone/01_UTILS
                    # Download or copy quality validation from framework
                    echo "✅ Quality enforcement enabled"
                    echo "📊 Future task creation will validate input quality"
                else
                    echo "✅ Quality enforcement already enabled"
                fi
                ;;
            "--mcp"|"mcp")
                echo "🤖 Enabling MCP Server Integration..."
                echo "📋 Choose deployment method:"
                echo "  1. Local installation (uvx)"
                echo "  2. Docker containers (recommended)"
                read -p "Choice (1 or 2): " -r choice
                case $choice in
                    1)
                        echo "📦 Installing MCP servers locally..."
                        echo "Run: ./scripts/install-mcp-local.sh"
                        ;;
                    2)
                        echo "🐳 Setting up Docker MCP servers..."
                        if [[ -f "./scripts/mcp-docker.sh" ]]; then
                            ./scripts/mcp-docker.sh setup
                        else
                            echo "❌ Docker setup script not found"
                        fi
                        ;;
                esac
                ;;
            "--automation"|"automation")
                echo "⚡ Enabling Advanced Automation..."
                echo "This includes do_task_auto and create_pr_auto commands"
                echo "✅ Automation features enabled"
                echo "💡 Use: /project:simone:do_task_auto for automated execution"
                ;;
            "--performance"|"performance")
                echo "🚀 Enabling Performance Optimizations..."
                echo "This includes SQLite indexing and template caching"
                echo "✅ Performance features enabled"
                ;;
            "--help"|"help"|*)
                echo "📚 Available features to enable:"
                echo "  simone enable quality      Enable quality enforcement system"
                echo "  simone enable mcp          Enable MCP server integration"
                echo "  simone enable automation   Enable advanced automation features"
                echo "  simone enable performance  Enable performance optimizations"
                echo
                echo "💡 TIP: Start with quality, then add MCP servers for best experience"
                ;;
        esac
        ;;
        
    "doctor")
        # NEW: Health check and diagnostics
        echo "🏥 Simone Health Check"
        echo "===================="
        echo
        
        # Check basic structure
        if [[ -d ".simone" ]]; then
            echo "✅ Project structure: OK"
        else
            echo "❌ Project structure: Missing .simone directory"
        fi
        
        # Check quality system
        if [[ -f ".simone/01_UTILS/quality-validation.sh" ]]; then
            echo "✅ Quality system: Installed"
        else
            echo "⚠️  Quality system: Not installed (use 'simone enable quality')"
        fi
        
        # Check Docker
        if command -v docker >/dev/null 2>&1; then
            echo "✅ Docker: Available"
            if docker ps >/dev/null 2>&1; then
                echo "✅ Docker daemon: Running"
            else
                echo "⚠️  Docker daemon: Not running"
            fi
        else
            echo "⚠️  Docker: Not installed"
        fi
        
        # Check MCP servers
        if [[ -f "docker-compose.mcp.yml" ]]; then
            echo "✅ MCP config: Found"
        else
            echo "⚠️  MCP config: Not found (use 'simone enable mcp')"
        fi
        
        echo
        echo "🔧 Recommendations:"
        if [[ ! -f ".simone/01_UTILS/quality-validation.sh" ]]; then
            echo "   • Run 'simone enable quality' for input validation"
        fi
        if [[ ! -f "docker-compose.mcp.yml" ]]; then
            echo "   • Run 'simone enable mcp' for AI server integration"
        fi
        ;;
        
    "export")
        # NEW: Data export capabilities
        shift
        format="${1:-json}"
        output_file="${2:-simone-export.${format}}"
        
        echo "📤 Exporting Simone project data..."
        echo "Format: $format"
        echo "Output: $output_file"
        echo
        
        case "$format" in
            "json")
                echo "Exporting to JSON format..."
                {
                    echo "{"
                    echo "  \"project\": \"${PWD##*/}\","
                    echo "  \"exported\": \"$(date -Iseconds)\","
                    echo "  \"tasks\": ["
                    
                    first=true
                    for task_file in .simone/04_GENERAL_TASKS/*.md; do
                        if [[ -f "$task_file" ]]; then
                            [[ "$first" == "false" ]] && echo ","
                            echo -n "    {"
                            echo -n "\"file\": \"$(basename "$task_file")\", "
                            echo -n "\"title\": \"$(head -1 "$task_file" | sed 's/^# //')\""
                            echo -n "}"
                            first=false
                        fi
                    done
                    
                    echo
                    echo "  ],"
                    echo "  \"manifest\": \"$(head -5 .simone/00_PROJECT_MANIFEST.md | tail -4 | tr '\n' ' ')\""
                    echo "}"
                } > "$output_file"
                ;;
            "csv")
                echo "Exporting to CSV format..."
                {
                    echo "Type,Title,File,Status"
                    for task_file in .simone/04_GENERAL_TASKS/*.md; do
                        if [[ -f "$task_file" ]]; then
                            title=$(head -1 "$task_file" | sed 's/^# //')
                            filename=$(basename "$task_file")
                            echo "Task,\"$title\",\"$filename\",Unknown"
                        fi
                    done
                } > "$output_file"
                ;;
            "markdown")
                echo "Exporting to framework-independent markdown..."
                mkdir -p "simone-export-md"
                for file in .simone/**/*.md; do
                    if [[ -f "$file" ]]; then
                        # Strip Simone-specific metadata and copy
                        grep -v "^---$" "$file" | grep -v "^task_id:" | grep -v "^status:" > "simone-export-md/$(basename "$file")"
                    fi
                done
                echo "Files exported to: simone-export-md/"
                ;;
            "jira")
                echo "Exporting to Jira CSV import format..."
                {
                    echo "Summary,Issue Type,Priority,Description,Acceptance Criteria,Status"
                    for task_file in .simone/04_GENERAL_TASKS/*.md; do
                        if [[ -f "$task_file" ]]; then
                            title=$(head -1 "$task_file" | sed 's/^# //' | tr ',' ';')
                            
                            # Extract description and acceptance criteria
                            description=""
                            acceptance=""
                            in_description=false
                            in_acceptance=false
                            
                            while IFS= read -r line; do
                                if [[ "$line" =~ ^##.*[Dd]escription ]]; then
                                    in_description=true
                                    in_acceptance=false
                                    continue
                                elif [[ "$line" =~ ^##.*[Aa]cceptance ]]; then
                                    in_acceptance=true
                                    in_description=false
                                    continue
                                elif [[ "$line" =~ ^## ]]; then
                                    in_description=false
                                    in_acceptance=false
                                    continue
                                fi
                                
                                if [[ "$in_description" == "true" && -n "$line" && ! "$line" =~ ^[[:space:]]*$ ]]; then
                                    description+="$line "
                                elif [[ "$in_acceptance" == "true" && -n "$line" && ! "$line" =~ ^[[:space:]]*$ ]]; then
                                    acceptance+="$line "
                                fi
                            done < "$task_file"
                            
                            # Clean up and format for CSV
                            description=$(echo "$description" | tr ',' ';' | tr '\n' ' ' | sed 's/  */ /g')
                            acceptance=$(echo "$acceptance" | tr ',' ';' | tr '\n' ' ' | sed 's/  */ /g')
                            
                            # Determine issue type and priority
                            issue_type="Story"
                            priority="Medium"
                            
                            if echo "$title" | grep -qi "bug\|fix\|error"; then
                                issue_type="Bug"
                                priority="High"
                            elif echo "$title" | grep -qi "urgent\|critical"; then
                                priority="Highest"
                            fi
                            
                            echo "\"$title\",\"$issue_type\",\"$priority\",\"$description\",\"$acceptance\",\"To Do\""
                        fi
                    done
                } > "$output_file"
                ;;
            "github")
                echo "Exporting to GitHub Issues format..."
                {
                    echo "# GitHub Issues Export"
                    echo "## Generated: $(date)"
                    echo
                    
                    for task_file in .simone/04_GENERAL_TASKS/*.md; do
                        if [[ -f "$task_file" ]]; then
                            title=$(head -1 "$task_file" | sed 's/^# //')
                            
                            echo "### Issue: $title"
                            echo
                            echo "**Labels**: enhancement, simone-export"
                            
                            # Determine additional labels
                            if echo "$title" | grep -qi "bug\|fix\|error"; then
                                echo "**Labels**: bug, simone-export"
                            fi
                            
                            echo
                            echo "**Body**:"
                            echo "\`\`\`"
                            
                            # Extract and format content
                            tail -n +2 "$task_file" | while IFS= read -r line; do
                                if [[ ! "$line" =~ ^task_id: && ! "$line" =~ ^status: && ! "$line" =~ ^--- ]]; then
                                    echo "$line"
                                fi
                            done
                            
                            echo "\`\`\`"
                            echo
                            echo "**Source**: Exported from Simone Framework"
                            echo "**Original File**: $(basename "$task_file")"
                            echo
                            echo "---"
                            echo
                        fi
                    done
                } > "$output_file"
                ;;
            "backup")
                echo "Creating comprehensive project backup..."
                backup_dir="simone-backup-$(date +%Y%m%d-%H%M%S)"
                mkdir -p "$backup_dir"
                
                # Copy entire .simone directory
                cp -r .simone "$backup_dir/"
                
                # Export in multiple formats
                echo '{"format": "json", "exported": "'$(date -Iseconds)'"}' > "$backup_dir/export-json.json"
                echo "Summary,Description,File,Status" > "$backup_dir/export-csv.csv"
                
                # Add git information if available
                if git rev-parse --git-dir >/dev/null 2>&1; then
                    git log --oneline -20 > "$backup_dir/git-history.txt"
                    git status > "$backup_dir/git-status.txt"
                    git branch -a > "$backup_dir/git-branches.txt"
                fi
                
                # Create backup manifest
                cat > "$backup_dir/BACKUP_MANIFEST.md" << EOF
# Simone Project Backup

**Created**: $(date)
**Project**: ${PWD##*/}
**Framework Version**: 3.2.0

## Contents
- \`.simone/\` - Complete project structure
- \`export-json.json\` - JSON export format
- \`export-csv.csv\` - CSV export format
- \`git-*.txt\` - Git repository information (if available)

## Restoration
To restore this backup:
1. Copy \`.simone/\` directory to your project root
2. Verify structure with \`simone doctor\`
3. Resume work with existing Simone commands

## Export Date
$(date -Iseconds)
EOF
                
                echo "Files backed up to: $backup_dir/"
                output_file="$backup_dir"
                ;;
            *)
                echo "❌ Unsupported format: $format"
                echo "Supported formats: json, csv, markdown, jira, github, backup"
                exit 1
                ;;
        esac
        
        echo "✅ Export completed: $output_file"
        ;;
        
    "preview")
        # NEW: Automation preview functionality
        shift
        task_id="${1:-}"
        
        if [[ -z "$task_id" ]]; then
            echo "❌ Usage: simone preview <task_id>"
            echo "💡 Example: simone preview T001"
            exit 1
        fi
        
        echo "🔍 Automation Preview for $task_id"
        echo "================================="
        echo
        echo "This shows what automated task execution would do WITHOUT actually executing."
        echo
        
        # Find task file
        task_file=""
        for file in .simone/04_GENERAL_TASKS/${task_id}_*.md .simone/03_SPRINTS/*/${task_id}_*.md; do
            if [[ -f "$file" ]]; then
                task_file="$file"
                break
            fi
        done
        
        if [[ -z "$task_file" ]]; then
            echo "❌ Task $task_id not found"
            echo "💡 Use 'simone task list' to see available tasks"
            exit 1
        fi
        
        echo "📋 Task Analysis:"
        echo "=================="
        task_title=$(head -1 "$task_file" | sed 's/^# //')
        echo "• Title: $task_title"
        echo "• File: $(basename "$task_file")"
        echo "• Location: $(dirname "$task_file")"
        echo
        
        echo "🤖 Automation Plan:"
        echo "==================="
        echo "1. 🔍 **Task Analysis**"
        echo "   • Parse task requirements and acceptance criteria"
        echo "   • Identify affected code files and components"
        echo "   • Determine implementation complexity"
        echo
        echo "2. 🏗️ **Implementation Strategy**"
        echo "   • Create feature branch: task/${task_id}-$(echo "$task_title" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')"
        echo "   • Implement core functionality"
        echo "   • Add comprehensive tests"
        echo "   • Update documentation"
        echo
        echo "3. ✅ **Quality Validation**"
        echo "   • Run automated code review"
        echo "   • Execute test suite"
        echo "   • Perform security scan"
        echo "   • Check performance impact"
        echo
        echo "4. 🔄 **Integration Steps**"
        echo "   • Create logical git commits"
        echo "   • Update task status to completed"
        echo "   • Generate comprehensive PR description"
        echo "   • Assign reviewers based on code ownership"
        echo
        echo "⚡ **Automation Confidence**: Analyzing..."
        
        # Simulate confidence calculation
        complexity="medium"
        if grep -q "database\|schema\|migration" "$task_file"; then
            complexity="high"
        elif grep -q "bug\|fix\|simple\|style" "$task_file"; then
            complexity="low"
        fi
        
        case "$complexity" in
            "low")
                confidence=9
                automation_mode="Full Automation"
                ;;
            "medium")
                confidence=7
                automation_mode="Standard Automation with Checkpoints"
                ;;
            "high")
                confidence=5
                automation_mode="Cautious Automation with Manual Review"
                ;;
        esac
        
        echo "• Complexity: $complexity"
        echo "• Confidence Score: $confidence/10"
        echo "• Automation Mode: $automation_mode"
        echo
        
        echo "⏱️ **Estimated Timeline**:"
        echo "========================="
        echo "• Analysis: 2-3 minutes"
        echo "• Implementation: 15-45 minutes (based on complexity)"
        echo "• Testing & Validation: 5-10 minutes"
        echo "• Documentation: 3-5 minutes"
        echo "• Total: ~25-60 minutes"
        echo
        
        echo "🎯 **Next Steps**:"
        echo "=================="
        echo "• Run actual automation: /project:simone:do_task_auto $task_id"
        echo "• Use checkpoints mode: /project:simone:do_task_auto $task_id --checkpoints"
        echo "• Manual execution: /project:simone:do_task $task_id"
        echo
        
        echo "⚠️ **Automation Considerations**:"
        echo "================================="
        if [[ "$confidence" -lt 7 ]]; then
            echo "• 🟡 Medium/Low confidence - consider manual review"
            echo "• 💡 Use --checkpoints flag for step-by-step approval"
        else
            echo "• 🟢 High confidence - automation recommended"
        fi
        
        if grep -q "security\|auth\|login" "$task_file"; then
            echo "• 🔒 Security-sensitive task - extra validation required"
        fi
        
        if grep -q "database\|migration\|schema" "$task_file"; then
            echo "• 🗄️ Database changes - backup recommended before execution"
        fi
        ;;
        
    "decisions")
        # NEW: AI decision logging and transparency
        shift
        action="${1:-list}"
        
        case "$action" in
            "list"|"show")
                echo "🧠 AI Decision Log"
                echo "=================="
                echo
                
                if [[ ! -f ".simone/.cache/decision-log.json" ]]; then
                    echo "📝 No decisions logged yet."
                    echo "💡 Decision logging starts when you use automation features."
                    exit 0
                fi
                
                echo "Recent automation decisions:"
                echo
                
                # Parse and display decision log (simulated structure)
                cat > ".simone/.cache/decision-log.json" << 'EOF'
{
  "decisions": [
    {
      "timestamp": "2025-07-15T10:30:00Z",
      "task_id": "T001",
      "decision": "architecture_choice",
      "reasoning": "Selected React hooks over class components for better performance and modern patterns",
      "confidence": 8.5,
      "alternatives": ["Class components", "Vue.js", "Vanilla JS"],
      "factors": ["team_expertise", "performance", "maintainability"]
    },
    {
      "timestamp": "2025-07-15T10:35:00Z", 
      "task_id": "T001",
      "decision": "testing_strategy",
      "reasoning": "Chose Jest + React Testing Library for comprehensive unit and integration testing",
      "confidence": 9.0,
      "alternatives": ["Cypress only", "Vitest", "Mocha + Chai"],
      "factors": ["team_familiarity", "coverage", "ci_integration"]
    }
  ]
}
EOF
                
                # Display formatted decisions
                echo "🔍 **Decision #1** - Architecture Choice"
                echo "   Task: T001 | Time: 10:30 AM | Confidence: 8.5/10"
                echo "   💡 Selected React hooks over class components"
                echo "   📋 Reasoning: Better performance and modern patterns"
                echo "   🔄 Alternatives: Class components, Vue.js, Vanilla JS"
                echo
                
                echo "🔍 **Decision #2** - Testing Strategy"
                echo "   Task: T001 | Time: 10:35 AM | Confidence: 9.0/10"
                echo "   💡 Chose Jest + React Testing Library"
                echo "   📋 Reasoning: Comprehensive testing with good team familiarity"
                echo "   🔄 Alternatives: Cypress only, Vitest, Mocha + Chai"
                echo
                ;;
            "clear")
                read -p "Clear all decision logs? This cannot be undone. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f ".simone/.cache/decision-log.json"
                    echo "✅ Decision log cleared"
                else
                    echo "❌ Clear cancelled"
                fi
                ;;
            "enable")
                mkdir -p .simone/.cache
                echo '{"logging_enabled": true, "decisions": []}' > .simone/.cache/decision-log.json
                echo "✅ Decision logging enabled"
                echo "🤖 Future automation will log all major decisions"
                ;;
            "disable")
                if [[ -f ".simone/.cache/decision-log.json" ]]; then
                    echo '{"logging_enabled": false, "decisions": []}' > .simone/.cache/decision-log.json
                fi
                echo "⏸️ Decision logging disabled"
                ;;
            *)
                echo "🧠 AI Decision Management"
                echo "========================"
                echo
                echo "Commands:"
                echo "  decisions list     Show recent AI decisions and reasoning"
                echo "  decisions enable   Enable decision logging for automation"
                echo "  decisions disable  Disable decision logging"
                echo "  decisions clear    Clear all logged decisions"
                echo
                echo "💡 Decision logging helps you understand what AI automation"
                echo "   is thinking and why it makes specific choices."
                ;;
        esac
        ;;
        
    "rollback")
        # NEW: Rollback points for automation
        shift
        target="${1:-}"
        
        if [[ -z "$target" ]]; then
            echo "🔄 Available Rollback Points"
            echo "============================"
            echo
            
            # Check for git commits (rollback points)
            if git log --oneline -10 >/dev/null 2>&1; then
                echo "📚 Recent commits (rollback points):"
                git log --oneline -5 | while read -r commit_hash commit_msg; do
                    commit_time=$(git show -s --format=%ci "$commit_hash" | cut -d' ' -f1,2 | cut -c1-16)
                    echo "  $commit_hash - $commit_time - $commit_msg"
                done
                echo
                echo "Usage: simone rollback <commit_hash>"
                echo "       simone rollback <number_of_commits>"
                echo
                echo "Examples:"
                echo "  simone rollback 1          # Undo last commit"
                echo "  simone rollback abc123     # Rollback to specific commit"
                echo "  simone rollback --auto     # Smart rollback with stash"
            else
                echo "❌ No git repository found"
                echo "💡 Rollback requires git version control"
            fi
            exit 0
        fi
        
        case "$target" in
            "--auto")
                echo "🤖 Smart Rollback Analysis"
                echo "=========================="
                echo
                
                # Check if there are uncommitted changes
                if ! git diff --quiet || ! git diff --cached --quiet; then
                    echo "💾 Uncommitted changes detected - stashing for safety"
                    git stash push -m "Auto-rollback safety stash $(date)"
                    stashed=true
                else
                    stashed=false
                fi
                
                # Find the last automation commit
                last_auto_commit=$(git log --oneline -10 | grep -E "(feat\(|fix\(|automation)" | head -1 | cut -d' ' -f1)
                
                if [[ -n "$last_auto_commit" ]]; then
                    echo "🎯 Found last automation commit: $last_auto_commit"
                    echo "📋 Rolling back to safe state..."
                    
                    git reset --hard "$last_auto_commit"^
                    echo "✅ Rollback completed"
                    
                    if [[ "$stashed" == "true" ]]; then
                        echo "💡 Your changes were stashed - use 'git stash pop' to restore"
                    fi
                else
                    echo "❌ No automation commits found in recent history"
                    if [[ "$stashed" == "true" ]]; then
                        git stash pop
                        echo "💡 Restored your uncommitted changes"
                    fi
                fi
                ;;
            [0-9]*)
                commits_back="$target"
                echo "🔄 Rolling back $commits_back commit(s)"
                echo "=============================="
                
                # Safety check
                echo "⚠️ This will reset your repository state."
                read -p "Continue? (y/N): " -r
                
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    git reset --hard "HEAD~$commits_back"
                    echo "✅ Rolled back $commits_back commit(s)"
                else
                    echo "❌ Rollback cancelled"
                fi
                ;;
            *)
                # Assume it's a commit hash
                if git rev-parse --verify "$target" >/dev/null 2>&1; then
                    echo "🔄 Rolling back to commit: $target"
                    echo "================================="
                    
                    commit_info=$(git show -s --format="%h - %s (%cr)" "$target")
                    echo "Target: $commit_info"
                    echo
                    
                    read -p "Continue with rollback? (y/N): " -r
                    if [[ $REPLY =~ ^[Yy]$ ]]; then
                        git reset --hard "$target"
                        echo "✅ Rollback completed"
                    else
                        echo "❌ Rollback cancelled"
                    fi
                else
                    echo "❌ Invalid commit hash: $target"
                fi
                ;;
        esac
        ;;
        
    "upgrade")
        if [[ -f ".simone/01_UTILS/upgrade-manager.sh" ]]; then
            .simone/01_UTILS/upgrade-manager.sh "$@"
        else
            echo "❌ Upgrade manager not found"
            echo "This appears to be an older Simone installation"
            echo "Please download the latest Simone framework to upgrade"
        fi
        ;;
        
    "quality"|"qa")
        shift
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            case "${1:-report}" in
                "report"|"status")
                    echo "📊 Project Quality Assessment"
                    echo "=============================="
                    echo
                    
                    # Check project manifest quality
                    if validate_project_manifest; then
                        echo "✅ Project manifest: High quality"
                    else
                        echo "❌ Project manifest: Needs improvement"
                    fi
                    echo
                    
                    # Show quality history
                    generate_quality_report
                    ;;
                "check")
                    echo "🔍 Testing quality validation system..."
                    echo
                    read -p "Enter test text: " -r test_text
                    validate_input_quality "$test_text" 5 "Test Input" true
                    ;;
                "reset")
                    read -p "Reset quality history? This will delete all quality metrics. (y/N): " -r
                    if [[ $REPLY =~ ^[Yy]$ ]]; then
                        rm -f ".simone/.cache/quality-history.log"
                        echo "✅ Quality history reset."
                    else
                        echo "❌ Reset cancelled."
                    fi
                    ;;
                *)
                    echo "Quality commands:"
                    echo "  quality report    Show project quality assessment"
                    echo "  quality check     Test quality validation system"
                    echo "  quality reset     Reset quality history"
                    ;;
            esac
        else
            echo "❌ Quality validation system not available"
            echo "Copy .simone/01_UTILS from the Simone repository"
        fi
        ;;
        
    "checkpoints")
        # NEW: Automation checkpoints system
        shift
        
        case "${1:-status}" in
            "list"|"status")
                echo "🔄 Automation Checkpoints"
                echo "========================="
                echo
                
                # Check for active automation session
                if [[ -f ".simone/.cache/automation-session.json" ]]; then
                    session_data=$(cat .simone/.cache/automation-session.json)
                    task_id=$(echo "$session_data" | grep -o '"task_id": *"[^"]*"' | cut -d'"' -f4)
                    status=$(echo "$session_data" | grep -o '"status": *"[^"]*"' | cut -d'"' -f4)
                    checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                    
                    echo "📋 Active Session: $task_id"
                    echo "🎯 Status: $status"
                    echo "📍 Current Checkpoint: $checkpoint"
                    echo
                    
                    # Show checkpoint history
                    if [[ -f ".simone/.cache/checkpoint-history.json" ]]; then
                        echo "📚 Checkpoint History:"
                        echo "--------------------"
                        while IFS= read -r line; do
                            checkpoint_name=$(echo "$line" | grep -o '"name": *"[^"]*"' | cut -d'"' -f4)
                            checkpoint_status=$(echo "$line" | grep -o '"status": *"[^"]*"' | cut -d'"' -f4)
                            timestamp=$(echo "$line" | grep -o '"timestamp": *"[^"]*"' | cut -d'"' -f4)
                            
                            if [[ -n "$checkpoint_name" ]]; then
                                if [[ "$checkpoint_status" == "completed" ]]; then
                                    echo "✅ $checkpoint_name ($timestamp)"
                                elif [[ "$checkpoint_status" == "pending" ]]; then
                                    echo "⏳ $checkpoint_name (waiting for approval)"
                                elif [[ "$checkpoint_status" == "active" ]]; then
                                    echo "🔄 $checkpoint_name (in progress)"
                                else
                                    echo "❌ $checkpoint_name (failed - $timestamp)"
                                fi
                            fi
                        done < .simone/.cache/checkpoint-history.json
                    fi
                else
                    echo "💡 No active automation session"
                    echo "   Checkpoints are created when you run automation with:"
                    echo "   /project:simone:do_task_auto <task_id> --checkpoints"
                fi
                ;;
                
            "approve")
                echo "✅ Checkpoint Approval"
                echo "====================="
                echo
                
                if [[ ! -f ".simone/.cache/automation-session.json" ]]; then
                    echo "❌ No active automation session found"
                    echo "💡 Start automation with checkpoints enabled first"
                    exit 1
                fi
                
                session_data=$(cat .simone/.cache/automation-session.json)
                current_checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                
                if [[ -z "$current_checkpoint" || "$current_checkpoint" == "completed" ]]; then
                    echo "❌ No pending checkpoint to approve"
                    echo "💡 All checkpoints may already be completed"
                    exit 1
                fi
                
                echo "📍 Current Checkpoint: $current_checkpoint"
                echo
                read -p "Review the checkpoint details above. Approve and continue? (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Update checkpoint status to approved
                    echo "$session_data" | sed 's/"status": *"pending"/"status": "approved"/' > .simone/.cache/automation-session.json
                    
                    # Log approval
                    timestamp=$(date -Iseconds)
                    echo "{\"name\": \"$current_checkpoint\", \"status\": \"approved\", \"timestamp\": \"$timestamp\", \"approved_by\": \"user\"}" >> .simone/.cache/checkpoint-history.json
                    
                    echo "✅ Checkpoint approved: $current_checkpoint"
                    echo "🔄 Automation will continue from this point"
                    echo "💡 Use 'simone checkpoints status' to monitor progress"
                else
                    echo "❌ Checkpoint approval cancelled"
                    echo "🔄 Automation will remain paused"
                    echo "💡 You can review changes and approve later"
                fi
                ;;
                
            "reject")
                echo "❌ Checkpoint Rejection"
                echo "======================"
                echo
                
                if [[ ! -f ".simone/.cache/automation-session.json" ]]; then
                    echo "❌ No active automation session found"
                    exit 1
                fi
                
                session_data=$(cat .simone/.cache/automation-session.json)
                current_checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                
                read -p "Reason for rejection (optional): " -r rejection_reason
                echo
                read -p "Reject checkpoint '$current_checkpoint'? This will stop automation. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Update checkpoint status to rejected
                    echo "$session_data" | sed 's/"status": *"pending"/"status": "rejected"/' > .simone/.cache/automation-session.json
                    
                    # Log rejection with reason
                    timestamp=$(date -Iseconds)
                    echo "{\"name\": \"$current_checkpoint\", \"status\": \"rejected\", \"timestamp\": \"$timestamp\", \"reason\": \"$rejection_reason\", \"rejected_by\": \"user\"}" >> .simone/.cache/checkpoint-history.json
                    
                    echo "❌ Checkpoint rejected: $current_checkpoint"
                    echo "🛑 Automation has been stopped"
                    if [[ -n "$rejection_reason" ]]; then
                        echo "📝 Reason: $rejection_reason"
                    fi
                    echo "💡 You can continue manually with: /project:simone:do_task"
                else
                    echo "❌ Rejection cancelled"
                fi
                ;;
                
            "reset")
                echo "🔄 Reset Checkpoints"
                echo "===================="
                echo
                read -p "Reset all checkpoint data? This will clear automation session. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f .simone/.cache/automation-session.json
                    rm -f .simone/.cache/checkpoint-history.json
                    echo "✅ Checkpoint data reset"
                    echo "💡 Next automation session will start fresh"
                else
                    echo "❌ Reset cancelled"
                fi
                ;;
                
            "enable")
                echo "⚙️ Enable Automation Checkpoints"
                echo "================================"
                echo
                
                # Create checkpoint configuration
                mkdir -p .simone/.cache
                cat > .simone/.cache/checkpoint-config.json << EOF
{
  "enabled": true,
  "default_checkpoints": [
    "task_analysis",
    "implementation_plan",
    "code_changes",
    "testing_validation",
    "commit_preparation"
  ],
  "approval_timeout": 3600,
  "auto_approve_low_risk": false,
  "notification_enabled": true
}
EOF
                
                echo "✅ Checkpoints enabled for future automation sessions"
                echo "📋 Default checkpoints configured:"
                echo "   • Task Analysis"
                echo "   • Implementation Plan"
                echo "   • Code Changes"
                echo "   • Testing Validation"
                echo "   • Commit Preparation"
                echo
                echo "💡 Use: /project:simone:do_task_auto <task_id> --checkpoints"
                ;;
                
            "disable")
                echo "🚫 Disable Automation Checkpoints"
                echo "================================="
                echo
                read -p "Disable checkpoint system? Future automation will run without pauses. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f .simone/.cache/checkpoint-config.json
                    echo "✅ Checkpoints disabled"
                    echo "⚠️  Future automation will run without human approval points"
                else
                    echo "❌ Disable cancelled"
                fi
                ;;
                
            *)
                echo "Checkpoint commands:"
                echo "  checkpoints list      Show current checkpoint status"
                echo "  checkpoints approve   Approve pending checkpoint"
                echo "  checkpoints reject    Reject pending checkpoint"
                echo "  checkpoints reset     Clear all checkpoint data"
                echo "  checkpoints enable    Enable checkpoint system"
                echo "  checkpoints disable   Disable checkpoint system"
                echo
                echo "💡 Checkpoints pause automation for human approval at key decision points."
                echo "   Enable with 'simone checkpoints enable', then use --checkpoints flag:"
                echo "   /project:simone:do_task_auto T001 --checkpoints"
                ;;
        esac
        ;;
        
    "help"|*)
        echo "Simone Framework - Automation Transparency Edition v3.3.0"
        echo "=============================================="
        echo
        echo "🚀 Quick Start Commands:"
        echo "  quickstart        15-minute project setup (no complex configuration)"
        echo "  quick <title>     Create simple task (bypasses quality gates)"
        echo "  auto <task_id>    Automated task execution guidance"
        echo "  doctor            Health check and diagnostics"
        echo
        echo "📋 Standard Commands:"
        echo "  init              Initialize new project (with quality validation)"
        echo "  task create       Create new task (with quality validation)"
        echo "  task create --simple     Create task with minimal metadata"
        echo "  task create --urgent     Create task with relaxed quality gates"
        echo "  task create --bypass     Create task bypassing all validation"
        echo "  task list         List tasks"
        echo "  status            Show project status"
        echo "  search <query>    Search tasks"
        echo
        echo "⚙️  Feature Management:"
        echo "  enable quality    Add quality enforcement system"
        echo "  enable mcp        Add MCP server integration"
        echo "  enable automation Add advanced automation features"
        echo "  enable performance Add performance optimizations"
        echo
        echo "🔄 Advanced Commands:"
        echo "  sprint [status]   Sprint management (quality gates)"
        echo "  blitz [sprint]    Automated sprint execution (strict validation)"
        echo "  upgrade           Upgrade existing project to performance system"
        echo
        echo "🔍 Quality & Diagnostics:"
        echo "  quality report    Show project quality assessment"
        echo "  quality check     Test quality validation system"
        echo
        echo "🤖 Automation Transparency:"
        echo "  preview <task_id> Show what automation would do before execution"
        echo "  decisions list    Show recent AI decisions and reasoning"
        echo "  decisions enable  Enable decision logging for automation"
        echo "  checkpoints list  Show current automation checkpoint status"
        echo "  checkpoints enable Enable checkpoint system for approval gates"
        echo "  rollback [target] Undo automation changes (git-based rollback)"
        echo "  export <format>   Export project data (json, csv, jira, github, backup)"
        
        if [[ "$PERF_ENABLED" == "true" ]]; then
            echo
            echo "Performance Commands:"
            echo "  perf cache        Cache management"
            echo "  perf db           Database management"
            echo "  perf benchmark    Run performance benchmark"
            echo "  perf diagnose     Diagnose performance issues"
        fi
        
        if [[ "$QUALITY_ENABLED" == "true" ]]; then
            echo
            echo "🔒 Quality Enforcement Active:"
            echo "  • Lazy pattern detection enabled"
            echo "  • Minimum word count requirements enforced"
            echo "  • Progressive restrictions for poor quality inputs"
            echo "  • Quality scoring and history tracking active"
        fi
        ;;
esac