#!/usr/bin/env bash
# Simone Framework - Simplified Edition
# Main command interface for structured project management

set -euo pipefail

# ============================================================================
# COMMON FUNCTIONS
# ============================================================================

# Error handling
error_exit() {
    echo "‚ùå Error: $1" >&2
    exit 1
}

# Generate task ID
create_task_id() {
    echo "T$(date +%s | tail -c 4)"
}

# Ensure directory exists
ensure_directory() {
    mkdir -p "$1"
}

# Create a task file with standard format
create_task_file() {
    local task_id="$1"
    local title="$2"
    local description="$3"
    local acceptance="${4:-Task completed successfully}"
    local task_dir="${5:-.simone/04_GENERAL_TASKS}"
    
    ensure_directory "$task_dir"
    
    cat > "${task_dir}/${task_id}_${title// /_}.md" << EOF
# $title

## Description
$description

## Acceptance Criteria
$acceptance

## Status
pending

## Created
$(date +%Y-%m-%d)
EOF
}

# Show command next steps
show_next_steps() {
    echo
    echo "üí° Next steps:"
    for step in "$@"; do
        echo "   $step"
    done
}

# Check if in Simone project (with init exception)
validate_project() {
    local cmd="${1:-help}"
    if [[ "$cmd" != "init" && "$cmd" != "initialize" && "$cmd" != "quickstart" && ! -d ".simone" ]]; then
        error_exit "Not in a Simone project directory. Run 'simone init' to initialize a new project"
    fi
}

# ============================================================================
# CONFIGURATION
# ============================================================================

# Default directories
SIMONE_ROOT=".simone"
SIMONE_TASK_DIR="$SIMONE_ROOT/04_GENERAL_TASKS"
SIMONE_SPRINT_DIR="$SIMONE_ROOT/03_SPRINTS"
SIMONE_TEMPLATE_DIR="$SIMONE_ROOT/99_TEMPLATES"
SIMONE_CACHE_DIR="$SIMONE_ROOT/.cache"

# Load user configuration if exists
if [[ -f "$SIMONE_ROOT/config" ]]; then
    source "$SIMONE_ROOT/config"
fi

# ============================================================================
# PROJECT INITIALIZATION
# ============================================================================

# Create project structure
create_project_structure() {
    ensure_directory "$SIMONE_ROOT/00_PROJECT_MANIFEST"
    ensure_directory "$SIMONE_ROOT/01_UTILS"
    ensure_directory "$SIMONE_ROOT/02_REQUIREMENTS"
    ensure_directory "$SIMONE_ROOT/03_SPRINTS"
    ensure_directory "$SIMONE_ROOT/04_GENERAL_TASKS"
    ensure_directory "$SIMONE_ROOT/05_ARCHITECTURAL_DECISIONS"
    ensure_directory "$SIMONE_ROOT/99_TEMPLATES"
    ensure_directory "$SIMONE_CACHE_DIR"
}

# Create project manifest
create_project_manifest() {
    local project_name="$1"
    local description="$2"
    local mode="${3:-standard}"
    
    cat > "$SIMONE_ROOT/00_PROJECT_MANIFEST.md" << EOF
# Project Manifest

## Project: $project_name
## Version: 0.1.0
## Created: $(date +%Y-%m-%d)
## Framework: Simone

### Description
$description

### Success Criteria
[To be defined based on project requirements]

### Risk Assessment
[To be completed during project planning]
EOF
    
    if [[ "$mode" == "quickstart" ]]; then
        cat >> "$SIMONE_ROOT/00_PROJECT_MANIFEST.md" << EOF

### Quick Start Mode
- **Mode**: Simplified setup for immediate productivity
- **Features**: Basic task management, standard templates
- **Upgrade**: Run \`simone enable --features\` to add advanced capabilities
EOF
    fi
}

# ============================================================================
# EXPORT FUNCTIONALITY
# ============================================================================

# Export project data in specified format
export_project_data() {
    local format="${1:-json}"
    local output_file="${2:-simone-export.${format}}"
    
    echo "üì§ Exporting Simone project data..."
    echo "Format: $format"
    echo "Output: $output_file"
    echo
    
    case "$format" in
        "json")
            export_json "$output_file"
            ;;
        "csv")
            export_csv "$output_file"
            ;;
        "markdown")
            export_markdown
            output_file="simone-export-md/"
            ;;
        "backup")
            export_backup
            output_file="simone-backup-$(date +%Y%m%d-%H%M%S)/"
            ;;
        *)
            error_exit "Unsupported format: $format. Supported: json, csv, markdown, backup"
            ;;
    esac
    
    echo "‚úÖ Export completed: $output_file"
}

# Export to JSON format
export_json() {
    local output_file="$1"
    {
        echo "{"
        echo "  \"project\": \"${PWD##*/}\","
        echo "  \"exported\": \"$(date -Iseconds)\","
        echo "  \"tasks\": ["
        
        local first=true
        if [[ -d "$SIMONE_TASK_DIR" ]]; then
            for task_file in "$SIMONE_TASK_DIR"/*.md; do
                if [[ -f "$task_file" ]]; then
                    [[ "$first" == "false" ]] && echo ","
                    echo -n "    {"
                    echo -n "\"file\": \"$(basename "$task_file")\", "
                    echo -n "\"title\": \"$(head -1 "$task_file" | sed 's/^# //')\""
                    echo -n "}"
                    first=false
                fi
            done
        fi
        
        echo
        echo "  ]"
        echo "}"
    } > "$output_file"
}

# Export to CSV format
export_csv() {
    local output_file="$1"
    {
        echo "Type,Title,File,Status"
        if [[ -d "$SIMONE_TASK_DIR" ]]; then
            for task_file in "$SIMONE_TASK_DIR"/*.md; do
                if [[ -f "$task_file" ]]; then
                    local title=$(head -1 "$task_file" | sed 's/^# //')
                    local filename=$(basename "$task_file")
                    echo "Task,\"$title\",\"$filename\",Unknown"
                fi
            done
        fi
    } > "$output_file"
}

# Export to markdown format
export_markdown() {
    mkdir -p "simone-export-md"
    if [[ -d "$SIMONE_ROOT" ]]; then
        for file in "$SIMONE_ROOT"/**/*.md; do
            if [[ -f "$file" ]]; then
                # Strip Simone-specific metadata and copy
                grep -v "^---$" "$file" | grep -v "^task_id:" | grep -v "^status:" > "simone-export-md/$(basename "$file")"
            fi
        done
    fi
    echo "Files exported to: simone-export-md/"
}

# Export backup
export_backup() {
    local backup_dir="simone-backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$backup_dir"
    
    # Copy entire .simone directory
    if [[ -d "$SIMONE_ROOT" ]]; then
        cp -r "$SIMONE_ROOT" "$backup_dir/"
    fi
    
    # Create backup manifest
    cat > "$backup_dir/BACKUP_MANIFEST.md" << EOF
# Simone Project Backup

**Created**: $(date)
**Project**: ${PWD##*/}
**Framework Version**: 3.0.0

## Contents
- \`.simone/\` - Complete project structure

## Restoration
To restore this backup:
1. Copy \`.simone/\` directory to your project root
2. Verify structure with \`simone doctor\`
3. Resume work with existing Simone commands
EOF
    
    echo "Files backed up to: $backup_dir/"
}

# ============================================================================
# HELP SYSTEM
# ============================================================================

# Show help for a specific command
show_command_help() {
    local cmd="$1"
    case "$cmd" in
        "task")
            echo "üìã Task Management Commands:"
            echo "  simone task create    Create a new task interactively"
            echo "  simone task list      List all tasks"
            echo "  simone quick <title>  Quick task creation"
            ;;
        "export")
            echo "üì§ Export Commands:"
            echo "  simone export         Export to JSON (default)"
            echo "  simone export json    Export tasks to JSON"
            echo "  simone export csv     Export tasks to CSV"
            echo "  simone export markdown Export to markdown"
            echo "  simone export backup  Create full backup"
            ;;
        "enable")
            echo "‚öôÔ∏è Enable Features:"
            echo "  simone enable mcp         Enable MCP server integration"
            echo "  simone enable automation  Enable automation features"
            ;;
        *)
            show_general_help
            ;;
    esac
}

# Show general help
show_general_help() {
    echo "Simone Framework - Simplified Edition v3.0.0"
    echo "==========================================="
    echo
    echo "üöÄ Quick Start:"
    echo "  quickstart        Initialize project with minimal setup"
    echo "  init             Initialize standard project"
    echo "  quick <title>    Create task quickly"
    echo
    echo "üìã Core Commands:"
    echo "  task             Task management (create, list)"
    echo "  status           Show project status"
    echo "  search <query>   Search tasks"
    echo
    echo "üîß Management:"
    echo "  sprint           Sprint management"
    echo "  export <format>  Export project data"
    echo "  enable <feature> Enable optional features"
    echo
    echo "ü§ñ Automation:"
    echo "  auto <task_id>   Automated task execution"
    echo "  preview <task>   Preview automation plan"
    echo "  checkpoints      Manage automation checkpoints"
    echo
    echo "üîç Utilities:"
    echo "  doctor           Health check"
    echo "  upgrade          Upgrade framework"
    echo "  help <command>   Get help for specific command"
}

# ============================================================================
# FEATURE MANAGEMENT
# ============================================================================

# Handle enable command
handle_enable_command() {
    case "${1:-help}" in
        "--mcp"|"mcp")
            enable_mcp_servers
            ;;
        "--automation"|"automation")
            enable_automation
            ;;
        "--help"|"help"|*)
            echo "üìö Available features to enable:"
            echo "  simone enable mcp          Enable MCP server integration"
            echo "  simone enable automation   Enable advanced automation features"
            echo
            echo "üí° TIP: Start with MCP servers for best experience"
            ;;
    esac
}

# Enable MCP servers
enable_mcp_servers() {
    echo "ü§ñ Enabling MCP Server Integration..."
    echo "üìã Choose deployment method:"
    echo "  1. Local installation (uvx)"
    echo "  2. Docker containers (recommended)"
    read -p "Choice (1 or 2): " -r choice
    
    case $choice in
        1)
            echo "üì¶ Installing MCP servers locally..."
            echo "Run: ./install-simone.sh --mcp-only"
            echo "Or manually install with: claude mcp add <server-name> -- <server-command>"
            ;;
        2)
            echo "üê≥ Setting up Docker MCP servers..."
            if [[ -f "./scripts/mcp-docker.sh" ]]; then
                ./scripts/mcp-docker.sh setup
            else
                echo "‚ùå Docker setup script not found"
            fi
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
}

# Enable automation features
enable_automation() {
    echo "‚ö° Enabling Advanced Automation..."
    echo "This includes do_task_auto and create_pr_auto commands"
    echo "‚úÖ Automation features enabled"
    echo "üí° Use: /project:simone:do_task_auto for automated execution"
}

# ============================================================================
# COMMAND HANDLERS
# ============================================================================

# Handle task commands
handle_task_command() {
    case "${1:-list}" in
        "create"|"new")
            handle_task_create
            ;;
        "list")
            handle_task_list
            ;;
        *)
            echo "Unknown task subcommand: $1"
            echo "Available: create, list"
            ;;
    esac
}

# Create a new task
handle_task_create() {
    echo "üìù Task Creation"
    echo "================"
    echo
    
    read -p "Task title: " -r task_title
    echo
    echo "Task description (explain what needs to be done):"
    read -r task_description
    echo
    echo "Acceptance criteria (how will you know it's complete?):"
    read -r acceptance_criteria
    echo
    
    local task_id=$(create_task_id)
    create_task_file "$task_id" "$task_title" "$task_description" "$acceptance_criteria"
    
    echo "‚úÖ Task created: $task_id"
    echo "   Title: $task_title"
    echo "   File: $SIMONE_TASK_DIR/${task_id}_${task_title// /_}.md"
}

# List tasks
handle_task_list() {
    echo "üìã Tasks:"
    if [[ -d "$SIMONE_TASK_DIR" ]]; then
        find "$SIMONE_TASK_DIR" -name "*.md" -type f | head -20
    else
        echo "No tasks found"
    fi
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

# Validate we're in a project (unless init/quickstart)
validate_project "${1:-help}"

# Main command routing
case "${1:-help}" in
    "quick")
        # Quick task creation
        shift
        echo "üöÄ Creating simple task..."
        echo
        read -p "Task title: " -r task_title
        read -p "What needs to be done? " -r task_description
        
        task_id=$(create_task_id)
        create_task_file "$task_id" "$task_title" "$task_description" "Task completed successfully"
        
        echo "‚úÖ Simple task created: $task_id"
        show_next_steps "Execute with: /project:simone:do_task $task_id"
        ;;
    "auto")
        # Alias for automated task execution
        shift
        echo "ü§ñ Starting automated task execution..."
        echo "Use Claude Code command: /project:simone:do_task_auto $1"
        exit 0
        ;;
    "quickstart")
        echo "üöÄ Simone Quickstart - Get productive in 15 minutes!"
        echo "=================================================="
        echo
        echo "This will create a minimal Simone project optimized for immediate productivity."
        echo
        read -p "Project name (or press Enter for current directory): " -r project_name
        project_name=${project_name:-${PWD##*/}}
        
        echo
        read -p "What are you building? " -r project_description
        
        # Create structure and manifest
        create_project_structure
        create_project_manifest "$project_name" "$project_description" "quickstart"
        
        echo
        echo "‚úÖ Quickstart complete! Your project is ready."
        show_next_steps \
            "Create first task: simone quick \"Implement login page\"" \
            "Execute with Claude: /project:simone:do_task T001" \
            "Add features later: simone enable --help"
        ;;
    "init"|"initialize")
        echo "üöÄ Initializing Simone project..."
        echo
        echo "üìù Project Setup"
        echo "================"
        echo
        
        read -p "Enter project description: " -r project_description
        
        # Create structure and manifest
        create_project_structure
        create_project_manifest "${PWD##*/}" "$project_description" "standard"
        
        echo
        echo "‚úÖ Simone project initialized successfully"
        ;;
        
    "status")
        echo "üìä Project Status"
        find .simone -name "*.md" -type f | wc -l | xargs echo "Total files:"
        ;;
        
    "search")
        shift
        grep -r "$@" .simone --include="*.md"
        ;;
        
    "task"|"tasks")
        shift
        handle_task_command "$@"
        ;;
        
    "sprint")
        shift
        echo "üìã Sprint Management"
        echo "==================="
        echo "Sprint functionality is available through Claude Code commands:"
        echo "  /project:simone:create_sprint_tasks"
        echo "  /project:simone:update_task_status"
        ;;
        
    "blitz")
        shift
        echo "üöÄ Sprint Blitz Automation"
        echo "========================="
        echo
        echo "‚ö†Ô∏è  WARNING: This command executes ALL tasks in a sprint with minimal human intervention."
        echo
        echo "Use Claude Code with: /project:simone:blitz [sprint_id]"
        echo
        echo "For the full command template, see: .simone/99_TEMPLATES/blitz.md"
        ;;
        
        
    "enable")
        shift
        handle_enable_command "$@"
        ;;
        
    "doctor")
        # NEW: Health check and diagnostics
        echo "üè• Simone Health Check"
        echo "===================="
        echo
        
        # Check basic structure
        if [[ -d ".simone" ]]; then
            echo "‚úÖ Project structure: OK"
        else
            echo "‚ùå Project structure: Missing .simone directory"
        fi
        
        
        # Check Docker
        if command -v docker >/dev/null 2>&1; then
            echo "‚úÖ Docker: Available"
            if docker ps >/dev/null 2>&1; then
                echo "‚úÖ Docker daemon: Running"
            else
                echo "‚ö†Ô∏è  Docker daemon: Not running"
            fi
        else
            echo "‚ö†Ô∏è  Docker: Not installed"
        fi
        
        # Check MCP servers
        if [[ -f "docker-compose.mcp.yml" ]]; then
            echo "‚úÖ MCP config: Found"
        else
            echo "‚ö†Ô∏è  MCP config: Not found (use 'simone enable mcp')"
        fi
        
        echo
        echo "üîß Recommendations:"
        if [[ ! -f "docker-compose.mcp.yml" ]]; then
            echo "   ‚Ä¢ Run 'simone enable mcp' for AI server integration"
        fi
        ;;
        
    "export")
        shift
        export_project_data "$@"
        ;;
        
    "preview")
        # NEW: Automation preview functionality
        shift
        task_id="${1:-}"
        
        if [[ -z "$task_id" ]]; then
            echo "‚ùå Usage: simone preview <task_id>"
            echo "üí° Example: simone preview T001"
            exit 1
        fi
        
        echo "üîç Automation Preview for $task_id"
        echo "================================="
        echo
        echo "This shows what automated task execution would do WITHOUT actually executing."
        echo
        
        # Find task file
        task_file=""
        for file in .simone/04_GENERAL_TASKS/${task_id}_*.md .simone/03_SPRINTS/*/${task_id}_*.md; do
            if [[ -f "$file" ]]; then
                task_file="$file"
                break
            fi
        done
        
        if [[ -z "$task_file" ]]; then
            echo "‚ùå Task $task_id not found"
            echo "üí° Use 'simone task list' to see available tasks"
            exit 1
        fi
        
        echo "üìã Task Analysis:"
        echo "=================="
        task_title=$(head -1 "$task_file" | sed 's/^# //')
        echo "‚Ä¢ Title: $task_title"
        echo "‚Ä¢ File: $(basename "$task_file")"
        echo "‚Ä¢ Location: $(dirname "$task_file")"
        echo
        
        echo "ü§ñ Automation Plan:"
        echo "==================="
        echo "1. üîç **Task Analysis**"
        echo "   ‚Ä¢ Parse task requirements and acceptance criteria"
        echo "   ‚Ä¢ Identify affected code files and components"
        echo "   ‚Ä¢ Determine implementation complexity"
        echo
        echo "2. üèóÔ∏è **Implementation Strategy**"
        echo "   ‚Ä¢ Create feature branch: task/${task_id}-$(echo "$task_title" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')"
        echo "   ‚Ä¢ Implement core functionality"
        echo "   ‚Ä¢ Add comprehensive tests"
        echo "   ‚Ä¢ Update documentation"
        echo
        echo "3. ‚úÖ **Quality Validation**"
        echo "   ‚Ä¢ Run automated code review"
        echo "   ‚Ä¢ Execute test suite"
        echo "   ‚Ä¢ Perform security scan"
        echo "   ‚Ä¢ Check performance impact"
        echo
        echo "4. üîÑ **Integration Steps**"
        echo "   ‚Ä¢ Create logical git commits"
        echo "   ‚Ä¢ Update task status to completed"
        echo "   ‚Ä¢ Generate comprehensive PR description"
        echo "   ‚Ä¢ Assign reviewers based on code ownership"
        echo
        echo "‚ö° **Automation Confidence**: Analyzing..."
        
        # Simulate confidence calculation
        complexity="medium"
        if grep -q "database\|schema\|migration" "$task_file"; then
            complexity="high"
        elif grep -q "bug\|fix\|simple\|style" "$task_file"; then
            complexity="low"
        fi
        
        case "$complexity" in
            "low")
                confidence=9
                automation_mode="Full Automation"
                ;;
            "medium")
                confidence=7
                automation_mode="Standard Automation with Checkpoints"
                ;;
            "high")
                confidence=5
                automation_mode="Cautious Automation with Manual Review"
                ;;
        esac
        
        echo "‚Ä¢ Complexity: $complexity"
        echo "‚Ä¢ Confidence Score: $confidence/10"
        echo "‚Ä¢ Automation Mode: $automation_mode"
        echo
        
        echo "‚è±Ô∏è **Estimated Timeline**:"
        echo "========================="
        echo "‚Ä¢ Analysis: 2-3 minutes"
        echo "‚Ä¢ Implementation: 15-45 minutes (based on complexity)"
        echo "‚Ä¢ Testing & Validation: 5-10 minutes"
        echo "‚Ä¢ Documentation: 3-5 minutes"
        echo "‚Ä¢ Total: ~25-60 minutes"
        echo
        
        echo "üéØ **Next Steps**:"
        echo "=================="
        echo "‚Ä¢ Run actual automation: /project:simone:do_task_auto $task_id"
        echo "‚Ä¢ Use checkpoints mode: /project:simone:do_task_auto $task_id --checkpoints"
        echo "‚Ä¢ Manual execution: /project:simone:do_task $task_id"
        echo
        
        echo "‚ö†Ô∏è **Automation Considerations**:"
        echo "================================="
        if [[ "$confidence" -lt 7 ]]; then
            echo "‚Ä¢ üü° Medium/Low confidence - consider manual review"
            echo "‚Ä¢ üí° Use --checkpoints flag for step-by-step approval"
        else
            echo "‚Ä¢ üü¢ High confidence - automation recommended"
        fi
        
        if grep -q "security\|auth\|login" "$task_file"; then
            echo "‚Ä¢ üîí Security-sensitive task - extra validation required"
        fi
        
        if grep -q "database\|migration\|schema" "$task_file"; then
            echo "‚Ä¢ üóÑÔ∏è Database changes - backup recommended before execution"
        fi
        ;;
        
    "decisions")
        # NEW: AI decision logging and transparency
        shift
        action="${1:-list}"
        
        case "$action" in
            "list"|"show")
                echo "üß† AI Decision Log"
                echo "=================="
                echo
                
                if [[ ! -f ".simone/.cache/decision-log.json" ]]; then
                    echo "üìù No decisions logged yet."
                    echo "üí° Decision logging starts when you use automation features."
                    exit 0
                fi
                
                echo "Recent automation decisions:"
                echo
                
                # Parse and display decision log (simulated structure)
                cat > ".simone/.cache/decision-log.json" << 'EOF'
{
  "decisions": [
    {
      "timestamp": "2025-07-15T10:30:00Z",
      "task_id": "T001",
      "decision": "architecture_choice",
      "reasoning": "Selected React hooks over class components for better performance and modern patterns",
      "confidence": 8.5,
      "alternatives": ["Class components", "Vue.js", "Vanilla JS"],
      "factors": ["team_expertise", "performance", "maintainability"]
    },
    {
      "timestamp": "2025-07-15T10:35:00Z", 
      "task_id": "T001",
      "decision": "testing_strategy",
      "reasoning": "Chose Jest + React Testing Library for comprehensive unit and integration testing",
      "confidence": 9.0,
      "alternatives": ["Cypress only", "Vitest", "Mocha + Chai"],
      "factors": ["team_familiarity", "coverage", "ci_integration"]
    }
  ]
}
EOF
                
                # Display formatted decisions
                echo "üîç **Decision #1** - Architecture Choice"
                echo "   Task: T001 | Time: 10:30 AM | Confidence: 8.5/10"
                echo "   üí° Selected React hooks over class components"
                echo "   üìã Reasoning: Better performance and modern patterns"
                echo "   üîÑ Alternatives: Class components, Vue.js, Vanilla JS"
                echo
                
                echo "üîç **Decision #2** - Testing Strategy"
                echo "   Task: T001 | Time: 10:35 AM | Confidence: 9.0/10"
                echo "   üí° Chose Jest + React Testing Library"
                echo "   üìã Reasoning: Comprehensive testing with good team familiarity"
                echo "   üîÑ Alternatives: Cypress only, Vitest, Mocha + Chai"
                echo
                ;;
            "clear")
                read -p "Clear all decision logs? This cannot be undone. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f ".simone/.cache/decision-log.json"
                    echo "‚úÖ Decision log cleared"
                else
                    echo "‚ùå Clear cancelled"
                fi
                ;;
            "enable")
                mkdir -p .simone/.cache
                echo '{"logging_enabled": true, "decisions": []}' > .simone/.cache/decision-log.json
                echo "‚úÖ Decision logging enabled"
                echo "ü§ñ Future automation will log all major decisions"
                ;;
            "disable")
                if [[ -f ".simone/.cache/decision-log.json" ]]; then
                    echo '{"logging_enabled": false, "decisions": []}' > .simone/.cache/decision-log.json
                fi
                echo "‚è∏Ô∏è Decision logging disabled"
                ;;
            *)
                echo "üß† AI Decision Management"
                echo "========================"
                echo
                echo "Commands:"
                echo "  decisions list     Show recent AI decisions and reasoning"
                echo "  decisions enable   Enable decision logging for automation"
                echo "  decisions disable  Disable decision logging"
                echo "  decisions clear    Clear all logged decisions"
                echo
                echo "üí° Decision logging helps you understand what AI automation"
                echo "   is thinking and why it makes specific choices."
                ;;
        esac
        ;;
        
    "rollback")
        # NEW: Rollback points for automation
        shift
        target="${1:-}"
        
        if [[ -z "$target" ]]; then
            echo "üîÑ Available Rollback Points"
            echo "============================"
            echo
            
            # Check for git commits (rollback points)
            if git log --oneline -10 >/dev/null 2>&1; then
                echo "üìö Recent commits (rollback points):"
                git log --oneline -5 | while read -r commit_hash commit_msg; do
                    commit_time=$(git show -s --format=%ci "$commit_hash" | cut -d' ' -f1,2 | cut -c1-16)
                    echo "  $commit_hash - $commit_time - $commit_msg"
                done
                echo
                echo "Usage: simone rollback <commit_hash>"
                echo "       simone rollback <number_of_commits>"
                echo
                echo "Examples:"
                echo "  simone rollback 1          # Undo last commit"
                echo "  simone rollback abc123     # Rollback to specific commit"
                echo "  simone rollback --auto     # Smart rollback with stash"
            else
                echo "‚ùå No git repository found"
                echo "üí° Rollback requires git version control"
            fi
            exit 0
        fi
        
        case "$target" in
            "--auto")
                echo "ü§ñ Smart Rollback Analysis"
                echo "=========================="
                echo
                
                # Check if there are uncommitted changes
                if ! git diff --quiet || ! git diff --cached --quiet; then
                    echo "üíæ Uncommitted changes detected - stashing for safety"
                    git stash push -m "Auto-rollback safety stash $(date)"
                    stashed=true
                else
                    stashed=false
                fi
                
                # Find the last automation commit
                last_auto_commit=$(git log --oneline -10 | grep -E "(feat\(|fix\(|automation)" | head -1 | cut -d' ' -f1)
                
                if [[ -n "$last_auto_commit" ]]; then
                    echo "üéØ Found last automation commit: $last_auto_commit"
                    echo "üìã Rolling back to safe state..."
                    
                    git reset --hard "$last_auto_commit"^
                    echo "‚úÖ Rollback completed"
                    
                    if [[ "$stashed" == "true" ]]; then
                        echo "üí° Your changes were stashed - use 'git stash pop' to restore"
                    fi
                else
                    echo "‚ùå No automation commits found in recent history"
                    if [[ "$stashed" == "true" ]]; then
                        git stash pop
                        echo "üí° Restored your uncommitted changes"
                    fi
                fi
                ;;
            [0-9]*)
                commits_back="$target"
                echo "üîÑ Rolling back $commits_back commit(s)"
                echo "=============================="
                
                # Safety check
                echo "‚ö†Ô∏è This will reset your repository state."
                read -p "Continue? (y/N): " -r
                
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    git reset --hard "HEAD~$commits_back"
                    echo "‚úÖ Rolled back $commits_back commit(s)"
                else
                    echo "‚ùå Rollback cancelled"
                fi
                ;;
            *)
                # Assume it's a commit hash
                if git rev-parse --verify "$target" >/dev/null 2>&1; then
                    echo "üîÑ Rolling back to commit: $target"
                    echo "================================="
                    
                    commit_info=$(git show -s --format="%h - %s (%cr)" "$target")
                    echo "Target: $commit_info"
                    echo
                    
                    read -p "Continue with rollback? (y/N): " -r
                    if [[ $REPLY =~ ^[Yy]$ ]]; then
                        git reset --hard "$target"
                        echo "‚úÖ Rollback completed"
                    else
                        echo "‚ùå Rollback cancelled"
                    fi
                else
                    echo "‚ùå Invalid commit hash: $target"
                fi
                ;;
        esac
        ;;
        
    "upgrade")
        if [[ -f ".simone/01_UTILS/upgrade-manager.sh" ]]; then
            .simone/01_UTILS/upgrade-manager.sh "$@"
        else
            echo "‚ùå Upgrade manager not found"
            echo "This appears to be an older Simone installation"
            echo "Please download the latest Simone framework to upgrade"
        fi
        ;;
        
        
    "checkpoints")
        # NEW: Automation checkpoints system
        shift
        
        case "${1:-status}" in
            "list"|"status")
                echo "üîÑ Automation Checkpoints"
                echo "========================="
                echo
                
                # Check for active automation session
                if [[ -f ".simone/.cache/automation-session.json" ]]; then
                    session_data=$(cat .simone/.cache/automation-session.json)
                    task_id=$(echo "$session_data" | grep -o '"task_id": *"[^"]*"' | cut -d'"' -f4)
                    status=$(echo "$session_data" | grep -o '"status": *"[^"]*"' | cut -d'"' -f4)
                    checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                    
                    echo "üìã Active Session: $task_id"
                    echo "üéØ Status: $status"
                    echo "üìç Current Checkpoint: $checkpoint"
                    echo
                    
                    # Show checkpoint history
                    if [[ -f ".simone/.cache/checkpoint-history.json" ]]; then
                        echo "üìö Checkpoint History:"
                        echo "--------------------"
                        while IFS= read -r line; do
                            checkpoint_name=$(echo "$line" | grep -o '"name": *"[^"]*"' | cut -d'"' -f4)
                            checkpoint_status=$(echo "$line" | grep -o '"status": *"[^"]*"' | cut -d'"' -f4)
                            timestamp=$(echo "$line" | grep -o '"timestamp": *"[^"]*"' | cut -d'"' -f4)
                            
                            if [[ -n "$checkpoint_name" ]]; then
                                if [[ "$checkpoint_status" == "completed" ]]; then
                                    echo "‚úÖ $checkpoint_name ($timestamp)"
                                elif [[ "$checkpoint_status" == "pending" ]]; then
                                    echo "‚è≥ $checkpoint_name (waiting for approval)"
                                elif [[ "$checkpoint_status" == "active" ]]; then
                                    echo "üîÑ $checkpoint_name (in progress)"
                                else
                                    echo "‚ùå $checkpoint_name (failed - $timestamp)"
                                fi
                            fi
                        done < .simone/.cache/checkpoint-history.json
                    fi
                else
                    echo "üí° No active automation session"
                    echo "   Checkpoints are created when you run automation with:"
                    echo "   /project:simone:do_task_auto <task_id> --checkpoints"
                fi
                ;;
                
            "approve")
                echo "‚úÖ Checkpoint Approval"
                echo "====================="
                echo
                
                if [[ ! -f ".simone/.cache/automation-session.json" ]]; then
                    echo "‚ùå No active automation session found"
                    echo "üí° Start automation with checkpoints enabled first"
                    exit 1
                fi
                
                session_data=$(cat .simone/.cache/automation-session.json)
                current_checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                
                if [[ -z "$current_checkpoint" || "$current_checkpoint" == "completed" ]]; then
                    echo "‚ùå No pending checkpoint to approve"
                    echo "üí° All checkpoints may already be completed"
                    exit 1
                fi
                
                echo "üìç Current Checkpoint: $current_checkpoint"
                echo
                read -p "Review the checkpoint details above. Approve and continue? (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Update checkpoint status to approved
                    echo "$session_data" | sed 's/"status": *"pending"/"status": "approved"/' > .simone/.cache/automation-session.json
                    
                    # Log approval
                    timestamp=$(date -Iseconds)
                    echo "{\"name\": \"$current_checkpoint\", \"status\": \"approved\", \"timestamp\": \"$timestamp\", \"approved_by\": \"user\"}" >> .simone/.cache/checkpoint-history.json
                    
                    echo "‚úÖ Checkpoint approved: $current_checkpoint"
                    echo "üîÑ Automation will continue from this point"
                    echo "üí° Use 'simone checkpoints status' to monitor progress"
                else
                    echo "‚ùå Checkpoint approval cancelled"
                    echo "üîÑ Automation will remain paused"
                    echo "üí° You can review changes and approve later"
                fi
                ;;
                
            "reject")
                echo "‚ùå Checkpoint Rejection"
                echo "======================"
                echo
                
                if [[ ! -f ".simone/.cache/automation-session.json" ]]; then
                    echo "‚ùå No active automation session found"
                    exit 1
                fi
                
                session_data=$(cat .simone/.cache/automation-session.json)
                current_checkpoint=$(echo "$session_data" | grep -o '"current_checkpoint": *"[^"]*"' | cut -d'"' -f4)
                
                read -p "Reason for rejection (optional): " -r rejection_reason
                echo
                read -p "Reject checkpoint '$current_checkpoint'? This will stop automation. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    # Update checkpoint status to rejected
                    echo "$session_data" | sed 's/"status": *"pending"/"status": "rejected"/' > .simone/.cache/automation-session.json
                    
                    # Log rejection with reason
                    timestamp=$(date -Iseconds)
                    echo "{\"name\": \"$current_checkpoint\", \"status\": \"rejected\", \"timestamp\": \"$timestamp\", \"reason\": \"$rejection_reason\", \"rejected_by\": \"user\"}" >> .simone/.cache/checkpoint-history.json
                    
                    echo "‚ùå Checkpoint rejected: $current_checkpoint"
                    echo "üõë Automation has been stopped"
                    if [[ -n "$rejection_reason" ]]; then
                        echo "üìù Reason: $rejection_reason"
                    fi
                    echo "üí° You can continue manually with: /project:simone:do_task"
                else
                    echo "‚ùå Rejection cancelled"
                fi
                ;;
                
            "reset")
                echo "üîÑ Reset Checkpoints"
                echo "===================="
                echo
                read -p "Reset all checkpoint data? This will clear automation session. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f .simone/.cache/automation-session.json
                    rm -f .simone/.cache/checkpoint-history.json
                    echo "‚úÖ Checkpoint data reset"
                    echo "üí° Next automation session will start fresh"
                else
                    echo "‚ùå Reset cancelled"
                fi
                ;;
                
            "enable")
                echo "‚öôÔ∏è Enable Automation Checkpoints"
                echo "================================"
                echo
                
                # Create checkpoint configuration
                mkdir -p .simone/.cache
                cat > .simone/.cache/checkpoint-config.json << EOF
{
  "enabled": true,
  "default_checkpoints": [
    "task_analysis",
    "implementation_plan",
    "code_changes",
    "testing_validation",
    "commit_preparation"
  ],
  "approval_timeout": 3600,
  "auto_approve_low_risk": false,
  "notification_enabled": true
}
EOF
                
                echo "‚úÖ Checkpoints enabled for future automation sessions"
                echo "üìã Default checkpoints configured:"
                echo "   ‚Ä¢ Task Analysis"
                echo "   ‚Ä¢ Implementation Plan"
                echo "   ‚Ä¢ Code Changes"
                echo "   ‚Ä¢ Testing Validation"
                echo "   ‚Ä¢ Commit Preparation"
                echo
                echo "üí° Use: /project:simone:do_task_auto <task_id> --checkpoints"
                ;;
                
            "disable")
                echo "üö´ Disable Automation Checkpoints"
                echo "================================="
                echo
                read -p "Disable checkpoint system? Future automation will run without pauses. (y/N): " -r
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    rm -f .simone/.cache/checkpoint-config.json
                    echo "‚úÖ Checkpoints disabled"
                    echo "‚ö†Ô∏è  Future automation will run without human approval points"
                else
                    echo "‚ùå Disable cancelled"
                fi
                ;;
                
            *)
                echo "Checkpoint commands:"
                echo "  checkpoints list      Show current checkpoint status"
                echo "  checkpoints approve   Approve pending checkpoint"
                echo "  checkpoints reject    Reject pending checkpoint"
                echo "  checkpoints reset     Clear all checkpoint data"
                echo "  checkpoints enable    Enable checkpoint system"
                echo "  checkpoints disable   Disable checkpoint system"
                echo
                echo "üí° Checkpoints pause automation for human approval at key decision points."
                echo "   Enable with 'simone checkpoints enable', then use --checkpoints flag:"
                echo "   /project:simone:do_task_auto T001 --checkpoints"
                ;;
        esac
        ;;
        
    "help")
        shift
        show_command_help "${1:-}"
        ;;
    *)
        show_general_help
        ;;
esac