#!/bin/bash

# Simone Automated Quality Gate Validator
# Comprehensive validation pipeline for automated task execution
# Usage: ./quality-gate-validator.sh [--task-id TASK_ID] [--strict] [--bypass-non-critical]

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
LOG_FILE="${PROJECT_ROOT}/.simone/logs/quality-gate-$(date +%Y%m%d-%H%M%S).log"
CONFIG_FILE="${PROJECT_ROOT}/.simone/config/quality-gates.yml"

# Default thresholds
DEFAULT_TEST_COVERAGE=80
DEFAULT_COMPLEXITY_MAX=10
DEFAULT_SECURITY_SCORE="A"
DEFAULT_PERFORMANCE_BUDGET=3000

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Initialize logging
mkdir -p "$(dirname "$LOG_FILE")"
exec 1> >(tee -a "$LOG_FILE")
exec 2> >(tee -a "$LOG_FILE" >&2)

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >&2
}

success() {
    echo -e "${GREEN}✅ $1${NC}"
    log "SUCCESS: $1"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
    log "WARNING: $1"
}

error() {
    echo -e "${RED}❌ $1${NC}"
    log "ERROR: $1"
}

info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
    log "INFO: $1"
}

# Parse command line arguments
TASK_ID=""
STRICT_MODE=false
BYPASS_NON_CRITICAL=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --task-id)
            TASK_ID="$2"
            shift 2
            ;;
        --strict)
            STRICT_MODE=true
            shift
            ;;
        --bypass-non-critical)
            BYPASS_NON_CRITICAL=true
            shift
            ;;
        *)
            error "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Load configuration if exists
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        info "Loading quality gate configuration from $CONFIG_FILE"
        # Source configuration values (simplified for demo)
        # In practice, you'd parse YAML properly
    else
        info "Using default quality gate configuration"
    fi
}

# Validation functions
validate_git_state() {
    info "Validating Git repository state..."
    
    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        error "Uncommitted changes detected. Please commit or stash changes."
        return 1
    fi
    
    # Check if we're on a valid branch
    current_branch=$(git branch --show-current)
    if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
        warning "Working on main/master branch. Consider using a feature branch."
        if [[ "$STRICT_MODE" == "true" ]]; then
            error "Strict mode: Cannot work on main/master branch"
            return 1
        fi
    fi
    
    success "Git state validation passed"
    return 0
}

validate_dependencies() {
    info "Validating project dependencies..."
    
    local has_errors=false
    
    # Check for package.json and validate dependencies
    if [[ -f "package.json" ]]; then
        info "Checking npm dependencies..."
        
        # Check for security vulnerabilities
        if command -v npm &> /dev/null; then
            if ! npm audit --audit-level moderate; then
                error "npm audit found security vulnerabilities"
                has_errors=true
            fi
            
            # Check for outdated packages
            outdated_packages=$(npm outdated --depth=0 --json 2>/dev/null || echo "{}")
            if [[ "$outdated_packages" != "{}" ]]; then
                warning "Outdated packages detected. Consider updating."
                if [[ "$STRICT_MODE" == "true" ]]; then
                    error "Strict mode: Outdated packages not allowed"
                    has_errors=true
                fi
            fi
        fi
    fi
    
    # Check for Cargo.toml (Rust projects)
    if [[ -f "Cargo.toml" ]]; then
        info "Checking Cargo dependencies..."
        if command -v cargo &> /dev/null; then
            if ! cargo audit 2>/dev/null; then
                warning "cargo audit found potential issues"
                if [[ "$STRICT_MODE" == "true" ]]; then
                    has_errors=true
                fi
            fi
        fi
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Dependency validation passed"
    return 0
}

validate_code_quality() {
    info "Validating code quality..."
    
    local has_errors=false
    
    # Linting checks
    if [[ -f "package.json" ]] && command -v npm &> /dev/null; then
        if npm run lint --silent 2>/dev/null; then
            success "Linting passed"
        else
            error "Linting failed"
            has_errors=true
        fi
        
        # Type checking
        if npm run typecheck --silent 2>/dev/null; then
            success "Type checking passed"
        else
            error "Type checking failed"
            has_errors=true
        fi
    fi
    
    # Code complexity analysis (if available)
    if command -v complexity-report &> /dev/null; then
        complexity_score=$(complexity-report --format json src/ 2>/dev/null | jq '.averageComplexity // 0')
        if (( $(echo "$complexity_score > $DEFAULT_COMPLEXITY_MAX" | bc -l) )); then
            error "Code complexity ($complexity_score) exceeds threshold ($DEFAULT_COMPLEXITY_MAX)"
            has_errors=true
        else
            success "Code complexity within acceptable limits ($complexity_score)"
        fi
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Code quality validation passed"
    return 0
}

validate_security() {
    info "Validating security..."
    
    local has_errors=false
    local security_tools=()
    
    # Check for common security scanning tools
    if command -v semgrep &> /dev/null; then
        security_tools+=("semgrep")
    fi
    
    if command -v bandit &> /dev/null; then
        security_tools+=("bandit")
    fi
    
    if command -v safety &> /dev/null; then
        security_tools+=("safety")
    fi
    
    if command -v snyk &> /dev/null; then
        security_tools+=("snyk")
    fi
    
    if [[ ${#security_tools[@]} -eq 0 ]]; then
        warning "No security scanning tools found. Consider installing semgrep, bandit, safety, or snyk."
        if [[ "$STRICT_MODE" == "true" ]]; then
            error "Strict mode: Security scanning required"
            return 1
        fi
    else
        info "Running security scans with available tools: ${security_tools[*]}"
        
        for tool in "${security_tools[@]}"; do
            case $tool in
                semgrep)
                    if ! semgrep --config=auto --error 2>/dev/null; then
                        error "semgrep found security issues"
                        has_errors=true
                    fi
                    ;;
                bandit)
                    if ! bandit -r . -f json 2>/dev/null | jq -e '.results | length == 0' >/dev/null; then
                        error "bandit found security issues"
                        has_errors=true
                    fi
                    ;;
                safety)
                    if ! safety check --json 2>/dev/null | jq -e '. | length == 0' >/dev/null; then
                        error "safety found security vulnerabilities"
                        has_errors=true
                    fi
                    ;;
                snyk)
                    if ! snyk test --severity-threshold=medium 2>/dev/null; then
                        error "snyk found security vulnerabilities"
                        has_errors=true
                    fi
                    ;;
            esac
        done
    fi
    
    # Check for hardcoded secrets
    if command -v git &> /dev/null; then
        secret_patterns=(
            "password\s*=\s*[\"'][^\"']+[\"']"
            "api[_-]?key\s*=\s*[\"'][^\"']+[\"']"
            "secret\s*=\s*[\"'][^\"']+[\"']"
            "token\s*=\s*[\"'][^\"']+[\"']"
        )
        
        for pattern in "${secret_patterns[@]}"; do
            if git grep -i -E "$pattern" -- '*.js' '*.ts' '*.py' '*.go' '*.java' 2>/dev/null; then
                error "Potential hardcoded secret found: $pattern"
                has_errors=true
            fi
        done
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Security validation passed"
    return 0
}

validate_tests() {
    info "Validating test suite..."
    
    local has_errors=false
    
    # Run tests based on project type
    if [[ -f "package.json" ]] && command -v npm &> /dev/null; then
        info "Running npm test suite..."
        
        if npm test 2>/dev/null; then
            success "All tests passed"
        else
            error "Test suite failed"
            has_errors=true
        fi
        
        # Check test coverage
        if npm run test:coverage --silent 2>/dev/null; then
            # Extract coverage percentage (this is simplified)
            coverage_output=$(npm run test:coverage --silent 2>&1 || echo "")
            coverage_percent=$(echo "$coverage_output" | grep -oE '[0-9]+\.[0-9]+%' | head -1 | sed 's/%//')
            
            if [[ -n "$coverage_percent" ]]; then
                if (( $(echo "$coverage_percent < $DEFAULT_TEST_COVERAGE" | bc -l) )); then
                    error "Test coverage ($coverage_percent%) below threshold ($DEFAULT_TEST_COVERAGE%)"
                    has_errors=true
                else
                    success "Test coverage adequate ($coverage_percent%)"
                fi
            fi
        fi
    elif [[ -f "Cargo.toml" ]] && command -v cargo &> /dev/null; then
        info "Running Cargo test suite..."
        
        if cargo test; then
            success "All Cargo tests passed"
        else
            error "Cargo test suite failed"
            has_errors=true
        fi
    elif [[ -f "go.mod" ]] && command -v go &> /dev/null; then
        info "Running Go test suite..."
        
        if go test ./...; then
            success "All Go tests passed"
        else
            error "Go test suite failed"
            has_errors=true
        fi
    else
        warning "No recognized test framework found"
        if [[ "$STRICT_MODE" == "true" ]]; then
            error "Strict mode: Test suite required"
            has_errors=true
        fi
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Test validation passed"
    return 0
}

validate_performance() {
    info "Validating performance..."
    
    local has_errors=false
    
    # Basic performance checks
    if [[ -f "package.json" ]] && command -v npm &> /dev/null; then
        # Check bundle size (if webpack or similar is used)
        if npm run build --silent 2>/dev/null; then
            success "Build completed successfully"
            
            # Check for large bundle sizes (simplified check)
            if [[ -d "dist" ]]; then
                large_files=$(find dist -name "*.js" -size +1M 2>/dev/null || true)
                if [[ -n "$large_files" ]]; then
                    warning "Large JavaScript bundles detected:"
                    echo "$large_files"
                    if [[ "$STRICT_MODE" == "true" ]]; then
                        error "Strict mode: Large bundles not allowed"
                        has_errors=true
                    fi
                fi
            fi
        else
            error "Build failed"
            has_errors=true
        fi
    fi
    
    # Run performance tests if available
    if npm run test:performance --silent 2>/dev/null; then
        success "Performance tests passed"
    elif [[ "$STRICT_MODE" == "true" ]]; then
        warning "No performance tests found"
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Performance validation passed"
    return 0
}

validate_documentation() {
    info "Validating documentation..."
    
    local has_errors=false
    
    # Check for basic documentation files
    required_docs=("README.md")
    for doc in "${required_docs[@]}"; do
        if [[ ! -f "$doc" ]]; then
            warning "Missing required documentation: $doc"
            if [[ "$STRICT_MODE" == "true" ]]; then
                error "Strict mode: Required documentation missing"
                has_errors=true
            fi
        fi
    done
    
    # Check if documentation is up to date (basic check)
    if [[ -f "README.md" ]]; then
        readme_age=$(stat -c %Y README.md 2>/dev/null || stat -f %m README.md 2>/dev/null || echo 0)
        current_time=$(date +%s)
        age_days=$(( (current_time - readme_age) / 86400 ))
        
        if [[ $age_days -gt 30 ]]; then
            warning "README.md hasn't been updated in $age_days days"
        fi
    fi
    
    # Validate API documentation if available
    if npm run docs:validate --silent 2>/dev/null; then
        success "API documentation validation passed"
    fi
    
    if [[ "$has_errors" == "true" ]]; then
        return 1
    fi
    
    success "Documentation validation passed"
    return 0
}

# Generate quality report
generate_quality_report() {
    local validation_results=("$@")
    local overall_status="PASS"
    local critical_failures=0
    local warnings=0
    
    info "Generating quality gate report..."
    
    report_file="${PROJECT_ROOT}/.simone/reports/quality-gate-$(date +%Y%m%d-%H%M%S).json"
    mkdir -p "$(dirname "$report_file")"
    
    # Count failures and warnings
    for result in "${validation_results[@]}"; do
        case $result in
            *FAIL*)
                critical_failures=$((critical_failures + 1))
                overall_status="FAIL"
                ;;
            *WARN*)
                warnings=$((warnings + 1))
                ;;
        esac
    done
    
    # Generate JSON report
    cat > "$report_file" << EOF
{
  "timestamp": "$(date -Iseconds)",
  "task_id": "${TASK_ID}",
  "overall_status": "${overall_status}",
  "critical_failures": ${critical_failures},
  "warnings": ${warnings},
  "strict_mode": ${STRICT_MODE},
  "bypass_non_critical": ${BYPASS_NON_CRITICAL},
  "validation_results": [
$(printf '    "%s"' "${validation_results[@]}" | sed 's/$/,/' | sed '$s/,$//')
  ],
  "log_file": "${LOG_FILE}",
  "generated_by": "quality-gate-validator.sh"
}
EOF
    
    info "Quality report generated: $report_file"
    
    # Summary output
    echo
    echo "=========================================="
    echo "         QUALITY GATE SUMMARY"
    echo "=========================================="
    echo
    
    if [[ "$overall_status" == "PASS" ]]; then
        success "Overall Status: PASS"
        echo -e "${GREEN}🎉 All quality gates passed!${NC}"
    else
        error "Overall Status: FAIL"
        echo -e "${RED}💥 Quality gate validation failed!${NC}"
    fi
    
    echo
    echo "Critical Failures: $critical_failures"
    echo "Warnings: $warnings"
    echo "Task ID: ${TASK_ID:-'N/A'}"
    echo "Strict Mode: $STRICT_MODE"
    echo "Report: $report_file"
    echo "Log: $LOG_FILE"
    echo
    echo "=========================================="
    
    return $([[ "$overall_status" == "PASS" ]] && echo 0 || echo 1)
}

# Main execution
main() {
    info "Starting Simone Quality Gate Validation"
    info "Task ID: ${TASK_ID:-'Auto-detected'}"
    info "Strict Mode: $STRICT_MODE"
    info "Bypass Non-Critical: $BYPASS_NON_CRITICAL"
    
    load_config
    
    # Array to store validation results
    local validation_results=()
    local validation_functions=(
        "validate_git_state"
        "validate_dependencies"
        "validate_code_quality"
        "validate_security"
        "validate_tests"
        "validate_performance"
        "validate_documentation"
    )
    
    # Run all validations
    for func in "${validation_functions[@]}"; do
        info "Running $func..."
        
        if $func; then
            validation_results+=("$func: PASS")
        else
            if [[ "$BYPASS_NON_CRITICAL" == "true" ]] && [[ "$func" != "validate_security" ]] && [[ "$func" != "validate_tests" ]]; then
                validation_results+=("$func: FAIL (BYPASSED)")
                warning "$func failed but bypassed due to --bypass-non-critical flag"
            else
                validation_results+=("$func: FAIL")
            fi
        fi
        
        echo
    done
    
    # Generate final report
    generate_quality_report "${validation_results[@]}"
}

# Handle script termination
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        error "Quality gate validation failed with exit code $exit_code"
    fi
    exit $exit_code
}

trap cleanup EXIT

# Change to project root
cd "$PROJECT_ROOT"

# Run main function
main "$@"